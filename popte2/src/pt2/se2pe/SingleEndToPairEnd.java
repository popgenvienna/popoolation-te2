package pt2.se2pe;

import corete.misc.LogFactory;
import htsjdk.samtools.*;
import htsjdk.samtools.fastq.FastqReader;
import htsjdk.samtools.fastq.FastqRecord;
import pt2.CommandFormater;
import pt2.Main;

import java.io.File;
import java.io.IOException;
import java.util.LinkedList;
import java.util.logging.Logger;

/**
 * Main class that contains the se2pe sub-task. Combine information from pair-ends for the output of bwasw (Smith-Waterman algorithm)
 * The output have the following tags:
 *
 * Tags that comes from the bwasw alignment:
 * 		Tag:Type 	Description
 * 		=======================
 * 		AS:i		Alignment score generated by aligner
 * 		XS:i		Suboptimal alignment score
 * 		XF:i		Support from forward/reverse alignment
 * 		XE:i		Number of supporting seeds
 * 		XN:i		Number of ambiguous bases in the reference
 * 		NM:i		Edit distance to the reference, including ambiguous bases but excluding clipping
 *
 * Tags that we should add from the multiple-alignment/pair information
 * 		MQ:i		This is add by default with the set paired-end function
 * 		SA:Z        Other canonical alignments in a chimeric alignment, formatted as a semicolon-delimited list:(rname,pos,strand,CIGAR,mapQ,NM;)
 * 					Each element in the list represents a part of the chimeric alignment.  Conventionally, at a supplementary line, the rst element points to the primary line.
 * 					Acording to SAM spec. 27 July 2015 (http://samtools.github.io/hts-specs/SAMv1.pdf)
 * 		X0:i		Number of best hits (calculated based on a single-end alignment) -> it should have all the number of canonical alignments that are in SA:Z
 *
 *
 * TODO: unit tests
 * @author Daniel Gómez-Sánchez
 */
public class SingleEndToPairEnd {

	private static final String taskName = "se2pe";
	private boolean debug = false;

	// From the command line
	private FastqReader fastq1;
	private FastqReader fastq2;
	private SamReader bam1;
	private SamReader bam2;
	private SAMFileHeader header;
	private SAMFileWriter output;
	private Logger logger;

	// Optional parameters
	private static int maxAlignmentsSA = 3;

	/**
	 * Run the task
	 */
	public void run() {
		logger.info("Starting se2pe");
		CrosslinkProgressLogger progress = new CrosslinkProgressLogger(logger);
		try {
			// This SAMRecord objects are to keep track of non-current alignmets
			SAMRecord alignedTemp1 = null;
			SAMRecord alignedTemp2 = null;

			// Opening the iterators from the bam files
			SAMRecordIterator alignmentIterator1 = bam1.iterator();
			SAMRecordIterator alignmentIterator2 = bam2.iterator();
			while (fastq1.hasNext() && fastq2.hasNext()) {
				// read the two pairs
				FastqRecord record1 = fastq1.next();
				FastqRecord record2 = fastq2.next();
				// obtain the readName
				String readName = getReadNameFromPair(record1, record2);
				// starting the list with the records for a pair
				LinkedList<SAMRecord> aligned1 = new LinkedList<SAMRecord>();
				LinkedList<SAMRecord> aligned2 = new LinkedList<SAMRecord>();
				// filling the list with the records for this pair and store the next alignment
				alignedTemp1 = fillAlignedListAndGetNextRecord(alignmentIterator1, aligned1, readName, alignedTemp1);
				alignedTemp2 = fillAlignedListAndGetNextRecord(alignmentIterator2, aligned2, readName, alignedTemp2);
				// crosslinking
				Crosslink crosslinkPair = new Crosslink(record1, record2, aligned1, aligned2, header, maxAlignmentsSA);
				// add to the writer
				crosslinkPair.writeCrosslinkTo(output);
				// writeCrosslinkPair(crosslinkPair);
				// add to the logger
				progress.record(crosslinkPair);
			}
			// Close all the readers and exit with errors if the readers have more lines
			if (fastq1.hasNext() || fastq2.hasNext()) {
				closeIO();
				exitWithErrors("FASTQ inputs does not contain the same number of files", false);
			}
			progress.finishLog();
			closeIO();
			logger.info("Done - thank you for using PoPoolation TE2 ("+ Main.getVersionNumber()+")");
		} catch(Exception e) {
			if(debug) {
				e.printStackTrace();
			}
			exitWithErrors(e.getMessage()+" (unexpected error)", false);
		}
	}

	/**
	 * Get the readName based on the record pair
	 *
	 * @param record1	the first record
	 * @param record2 	the second record
	 * @return 			the read name without th /1 or /2 sequence at the end
	 */
	private static String getReadNameFromPair(FastqRecord record1, FastqRecord record2) {
		String readName1 = record1.getReadHeader().replaceAll("/[12]", "");
		String readName2 = record2.getReadHeader().replaceAll("/[12]", "");
		if(readName1.equals(readName2)) {
			return readName1;
		}
		throw new RuntimeException("Read names from FASTQ does not match: "+readName1+"!="+readName2);
	}

	/**
	 * Read the SamReader until it reach a record that does not match the readName, and store the results in the alignedList
	 * WARNING: the alignedList will be completely remove and should not contain anything important
	 *
	 * @param iterator       the iterator from read for
	 * @param alignedList    the list to store the records
	 * @param readName 		 the next record that does not match the readName
	 * @param previous       the previous record readed by this fuction; null otherwise
	 * @return				 the next record; if the iterator have finished, return null
	 */
	private static SAMRecord fillAlignedListAndGetNextRecord(SAMRecordIterator iterator, LinkedList<SAMRecord> alignedList, String readName, SAMRecord previous) {
		// if the previous is not null, add it to the list
		if(previous != null) {
			alignedList.add(previous);
		}
		// read from the iterator while it have a next one
		while(iterator.hasNext()) {
			// store in the previous the next record
			previous = iterator.next();
			// if it is still a read for the current processed name, add it to the list
			if(readName.equals(previous.getReadName().replaceAll("/[12]", ""))) {
				alignedList.add(previous);
			// if not, finish iteration returning the previous
			} else {
				return previous;
			}
		}
		// if we reach this code, it means that the iterator is finished and the last one is not a previous (because if not it returned), so return null
		return null;
	}

	@Deprecated
	private void writeCrosslinkPair(Crosslink pair) throws CloneNotSupportedException {
		output.addAlignment(pair.getFirstPair());
		output.addAlignment(pair.getSecondPair());
	}

	/**
	 * Close all the readers and writers
	 * @throws IOException
	 */
	private void closeIO() throws IOException {
		fastq1.close();
		fastq2.close();
		bam1.close();
		bam2.close();
		if(output.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.coordinate) {
			logger.info("Waiting for sorting to finish");
		}
		output.close();
	}

	/**
	 * Parse the command line and load the BAM/SAM files
	 *
	 * @param args the arguments without the task name
	 */
	public void parseCommandLine(LinkedList<String> args) {
		// Parsing the commands
		String fastq1 = null;
		String fastq2 = null;
		String bam1 = null;
		String bam2 = null;
		String output = null;
		boolean detailedLog = false;
		boolean sort = false;
		boolean index = false;
		for(int i = 0; i < args.size(); i++) {
			switch(args.get(i)) {
				case "--fastq1":		fastq1 = args.get(++i);
										break;
				case "--fastq2":		fastq2 = args.get(++i);
										break;
				case "--bam1":			bam1 = args.get(++i);
										break;
				case "--bam2":			bam2 = args.get(++i);
										break;
				case "--output":		output = args.get(++i);
										break;
				case "--detailed-log":	detailedLog = true;
										break;
				case "--sort":			sort = true;
										break;
				case "--index":			index = true;
										break;
				case "--n":				maxAlignmentsSA = Integer.parseInt(args.get(++i));
										break;
				case "--debug":			debug = true;
										break;
				default: 				exitWithErrors("Do not recognize command line option " + args.get(i), true);
			}
		}
		// Create the logger
		this.logger = LogFactory.getLogger(detailedLog);
		if(debug) {
			logger.warning("Debugging mode on");
		}
		// Check if the required inputs are set
		if(fastq1==null || fastq2 == null || bam1 == null || bam2 == null || output == null) {
			exitWithErrors("All main parameters are required", true);
		}
		String cmdLine = String.format("%s --fastq1 %s --fastq2 %s --bam1 %s --bam2 %s --output %s --n %s %s%s",
			taskName, fastq1, fastq2, bam1, bam2, output, maxAlignmentsSA, (sort) ? "--sort " : "", (index) ? "--index" : "");
		// Check if files exists and exit otherwise
		exists(fastq1);
		exists(fastq2);
		exists(bam1);
		exists(bam2);
		// Starting opening the files and setting the common stuff
		try {
			logger.info(String.format("Running popte2 with the following arguments: %s", cmdLine));
			// Open the FASTQ readers
			logger.fine("Reading input FASTQ files");
			this.fastq1 = new FastqReader(new File(fastq1));
			this.fastq2 = new FastqReader(new File(fastq2));
			// Open the SAM readers
			// TODO: I used the HTSJDK readers because they keep the current state of the flags, cigar string and so on.
			// TODO: In addition, I require htsjdk SamRecords for the SamFileWriter, if not is a pain in the ass to validate the output, and I need the SamHeader
			logger.fine("Reading input BAM/SAM files");
			this.bam1 = SamReaderFactory.makeDefault().validationStringency(ValidationStringency.SILENT).open(new File(bam1));
			this.bam2 = SamReaderFactory.makeDefault().validationStringency(ValidationStringency.SILENT).open(new File(bam2));
			// Check if both headers are the same
			if(!this.bam1.getFileHeader().equals(this.bam2.getFileHeader())) {
				exitWithErrors("BAM files should have the same header", false);
			}
			// Store the header
			this.header = this.bam1.getFileHeader();
			// Add the program to the header
			SAMProgramRecord programRecord = new SAMProgramRecord("popte2");
			programRecord.setProgramName("popte2");
			programRecord.setProgramVersion(Main.getVersionNumber());
			programRecord.setCommandLine(cmdLine);
			this.header.addProgramRecord(programRecord);
			// Create the output factory
			SAMFileWriterFactory factory = new SAMFileWriterFactory();
			// Log the index fine
			if(index) {
				logger.fine("Output will be indexed. Switching to 'sort' mode if not provided");
				sort = true;
			}
			if(sort) {
				// Change the sort ordering and log
				this.header.setSortOrder(SAMFileHeader.SortOrder.coordinate);
				logger.fine("Output will be sorted on the fly");
			} else {
				// Add unsorted ordering and log
				this.header.setSortOrder(SAMFileHeader.SortOrder.unsorted);
				logger.fine("Output file will be unsorted");
			}
			// set the index creation
			factory.setCreateIndex(index);
			// Open the output. Note: I use the htsjdk and not a wrapper because it could index and sort on the fly
			logger.fine("Creating output file");
			this.output = factory.makeSAMOrBAMWriter(header, false, new File(output));
		} catch(SAMException e) {
			// that means that an opening fails
			if(debug) {
				e.printStackTrace();
			}
			exitWithErrors(e.getMessage()+"Unexpected exception", false);
		}
	}

	private void exists(String fileName) {
		if(!new File(fileName).exists()) {
			exitWithErrors(fileName+" file does not exists", true);
		}
	}

	private void exitWithErrors(String msg, boolean printHelp) {
		if(printHelp) {
			printHelp();
			System.out.println();
			System.out.println("Error: "+msg);
		} else {
			logger.warning("Error: "+msg);
		}
		System.exit(1);
	}

	public static void printHelp()
	{
		StringBuilder sb=new StringBuilder();
		sb.append("Merge two sam/bam files and crosslink the paired-end information\n\n");

		sb.append("== Main parameters ==\n");
		sb.append(CommandFormater.format("--fastq1", "fastq file with first read pairs (gziped allowed)",true));
		sb.append(CommandFormater.format("--fastq2", "fastq file with second read pairs (gziped allowed)",true));
		sb.append(CommandFormater.format("--bam1", "bam/sam file with first read pairs",true));
		sb.append(CommandFormater.format("--bam2", "bam/sam file with second read pairs",true));
		sb.append(CommandFormater.format("--output", "Output file",true));
		sb.append("\n");
		sb.append("== Parameters for fine tuning ==\n");
		// this three following options comes from the bwa sampe program
		sb.append(CommandFormater.format("--n", "Maximum number of alignments to output in the SA tag. Tag will be ignored if numbers exceed this maximum", String.valueOf(maxAlignmentsSA)));
		sb.append(CommandFormater.format("--sort", "Sort the output file", false));
		sb.append(CommandFormater.format("--index", "Create an index for the output file (sort will be set by default)", null));
		sb.append(CommandFormater.format("--detailed-log", "Show a detailed event log", false));
		sb.append("\nSee the online manual for detailed description of the parameters\n");
		System.out.println(sb.toString());


	}

	//private static void formatMainOption(String name, String description) {
	//	System.out.println(String.format("--%-22s%s", name, description));
	//}

	//private static void formatOptionalOption(String name, String description, Object defaultValue) {
	//	System.out.println(String.format("--%-22s%s [%s]", name, description, defaultValue));
	//}

}
